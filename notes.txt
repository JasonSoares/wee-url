Dependencies:
- elixir 1.13
- node 16
- docker

Prerequisite:
To run the project, we need an instance of Postgresql running on port 5432 with username and password set to "postgres".
To quickly setup Postgres with the above requirements, run the following command:

`docker run -d -e POSTGRES_USER=postgres -e POSTGRES_PASSWORD=postgres -p 5432:5432 postgres:latest`

Getting setup:
1. Ensure that the above dependencies are installed, and Postgres is setup according to the prerequisite section above
2. Clone the project and change into the root directory of the project
3. Run `make setup` to install dependencies and prepare the project to run.

Running the server:
Be sure you have run `make setup` before running the following command.

`make server`

You may then access the app by opening a browser and navigating to `http://localhost:4000`

Running the tests:
Be sure you have run `make setup` before running the following command.

`make test`

This will run both the front-end and back-end test suites.

Usage:
The app provides a form that allows a user to submit a valid URL, and returns a short url with a unique slug. The short url
is placed in the form and the button changes from shorten to copy. This helps prevent someone from holding the enter key and
repeatedly submitting the form, and makes copying the url to the clipboard more convenient. The app keeps track of the 5 most
recent short URLs, and saves that data to local storage. The recent history list provides a clickable short URL and a copy button
if the user wants to share the link. In the event that a link is not found, there is a 404 page that explains what happened and
provides a link to get back to the main page to submit a short url.

Tech Stack:

The front-end is written with TypeScript and Tailwind CSS and uses React.
It utilizes react-hook-form for the main form.

The back-end is written in Elixir and uses the Phoenix framework. It also uses PostgreSQL to persist data.

Slug Generation:

Slugs need to have the following characteristics:

- unique
- short
- url-safe

Slugs are generated by using Erlang's `crypto.strong_rand_bytes` function, which generates randomly uniform bytes
which are then encoded using a URL-safe character set. The app uses 6 bytes, which results in a slug
length of 8 when encoded. At that size, there is a low probability of collision, but the app could be extended
to either try multiple times, or increase the number of bytes (and thus the slug length) if the app was popular enough to warrant
such a change.

Security Considerations:

The main threat for this app is for a user to generate short urls that link to other short urls thus causing
a redirect loop that could take the site down. To help prevent this, the front end inspects the url being submitted
and if the domain matches, it prevents submission. Additionally, the back-end uses PlugAttack to limit the calls
to the local ip only (so only the front end can make the calls due to it being hosted with the back-end). PlugAttack
is also setup to limit the rate based on ip address. This could be a problem if a large organization is using the
app from a shared ip address. Additional measures could be taken as well. For instance, a user could use another url
shortener to cause the redirect loop. To address this, the app could make use of a block list with known url shorteners,
and check against this list for every submission.

Performance:

If the app has some heavily-used short urls, then it could benefit from a caching layer to speed up the lookup and redirect.
I would wait and see how the app is being used before adding such a layer because if short URLs aren't heavily used, then there
would be little benefit. As mentioned under "Security Considerations," PlugAttack is used to rate-limit requests by ip address,
which allows for 5 requests per second. This helps ensure that a bad actor won't hog resources from everyone else.

If the app was extended to allow users to sign up and therefore "own" their links, then I would add a controller for listing the most
recent URLs from the back end, and would probably use something like ReactQuery to handle caching the recent URLs on the front end.

Future enhancements:
- Allow users to sign up and keep track of all of their short URLs
- Allow users to delete their own links in case they accidentally link to something they shouldn't
- Add analytics (click counter) and a dashboard view to surface that information
- Translations into multiple languages
